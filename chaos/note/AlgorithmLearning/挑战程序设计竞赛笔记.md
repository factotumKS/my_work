# 挑战程序设计竞赛笔记

## 二、初级篇

### 2.1、穷举搜索

#### 2.1.4、深度优先搜索(DFS, Depth-First Search)

​	在递归中直接体现分支，在叶节点才会返回，所以函数栈会累的很高。

```C++
 12 bool dfs(int i, int sum){
 13   if(i == maxn) return sum == k;
 14   //如果不加上A[i]
 15   if(dfs(i+1, sum)) return true;
 16   //如果加上A[i]
 17   if(dfs(i+1, sum+A[i])) return true;
 18   //不可行
 19   return false;
 20 }
```

​	一个找积水的问题，`*`表示积水，`.`表示地面，找有几个水坑。用dfs的思路就是每个位置都dfs一遍。虽说我觉得可以给`*`打标记，搜索(极坐标)45度到180度的四个方向，如果有已经标记的`*`就把这个标记继承下去(已有水坑)，如果没有(新水坑)就标记++，搜索范围会少很多。

```c++
*...*.*...****...
**.......***....*
*....*..*.*......
.....*..**......*
```



#### 2.1.5、宽度优先搜索(BFS, Breadth-First Search)

​	隐式地用到了队列，从初态开始，每需要搜索一个状态，就把下一步的可能状态加在队列尾，所以会在最后顺序遍历一遍叶节点。

​	走迷宫的问题，从`S`经`.`走到`E`，BFS使用一个和问题等大规模的数组来记录走到每个地方的距离，初始化为`INF`，后面用上面说的队列的方式更新。

```c++
####S########
...#.......#.
##...####....
E#####....##.
...........#.
```



```c++
const int INF = 100000000

//pair表示状态，换个名字方便一些
typedef pair<int, int> P;
    
char maze[maxN][maxM]; //迷宫字符串
int N, M;
int sx, sy; //起点坐标
int ex, ey; //终点坐标
int d[maxN][maxM];	//距离记录表

int bfs(){
    queue<P> que;
    //所有位置初始化为INF
    for(int i = 0; i < N; i++)
        for(int j = 0, j < M; j++) d[i][j] = INF;
    //初始化：加入起点
    que.push(P(sx, sy))
        
    //不断循环到队列长度为0
    while(que.size()){
    	...        
    }
}
```

​	4.5有注重内存占用的迭代加深深度优先搜索(IDDFS)



2.1.6、特殊状态的枚举

​	C++标准库的next_permutation函数，可把n个元素共n!种排列生成出来。mark一下，以后应该会用上。



#### 2.1.7、剪枝

​	前面dfs求部分和没有设置sum超过k就停止的条件，这一段枝本应该剪掉(不展开)。

​	注意堆内存和栈内存的防溢出。



### 2.2、贪心法

#### 2.2.2、贪心证明

​	贪心法都有一个贪心策略，这个策略使得我们提高了速度，但这是以减少搜索空间为代价的，这种减少可能是致命的(算法不正确，不返回最优解)。然而，在竞赛中证明并不重要，心里有数就行。



### 2.3、动态规划(Dynamic Programming)

#### 2.3.2、完全背包问题

​	



