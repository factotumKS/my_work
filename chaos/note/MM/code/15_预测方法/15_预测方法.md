# 15、预测方法

## 15.1、微分方程模型

​	微分方程建立基于因果预测法，既能反映事物内部规律，也有两个因素的相关关系；方程的基础是局部规律的独立性假设，故做中期预测，偏差比较大，微分方程也难以得到。

### 例子：硫磺岛战役



## 15.2、灰色预测模型

​	不是用原始数据序列，使用生成的数据序列；优点是需要数据少，精度高；缺点是只适用于中短期的预测，只适合指数增长的预测。

​	灰色预测输入的数据类型都只是一条数列，比较好控制。

### GM(1,1)

​	一阶微分方程，且变量数为1。$\frac{dx^{(1)}}{dt}+a^{(1)}=b$求解得到，$x^{(1)}(k+1)=(x^{(0)}(1)-\frac ba)e^{-ak}+\frac ba$

1. 数据检验与处理：根据一条数列给出序列的级比；
2. 建立模型：建立模型得到预测值；
3. 检验预测值：
   1. 残差检验：<0.2达到一般要求，<0.1达到较高要求；
   2. 级比偏差值检验：计算每一级k的实际级比同上
4. 预测预报：go ahead!

#### 例子： 北方城市道路交通噪声平均声级

​	给出北京1986到1992每年的道路交通平均声级。

```matlab
clc,clear
x0=[71.1 72.4 72.4 72.1 71.4 72.0 71.6]'; %注意这里为列向量
n=length(x0);
lamda=x0(1:n-1)./x0(2:n)  %计算级比
range=minmax(lamda')  %计算级比的范围
x1=cumsum(x0)  %累加运算
B=[-0.5*(x1(1:n-1)+x1(2:n)),ones(n-1,1)];
Y=x0(2:n);
u=B\Y  %拟合参数u(1)=a,u(2)=b
syms x(t)
x=dsolve(diff(x)+u(1)*x==u(2),x(0)==x0(1)); %求微分方程的符号解
xt=vpa(x,6) %以小数格式显示微分方程的解
%在此处预测
yuce1=subs(x,t,[0:n-1]); %求已知数据的预测值
yuce1=double(yuce1); %符号数转换成数值类型，否则无法作差分运算
yuce=[x0(1),diff(yuce1)]  %差分运算，还原数据
epsilon=x0'-yuce    %计算残差
delta=abs(epsilon./x0')  %计算相对误差
rho=1-(1-0.5*u(1))/(1+0.5*u(1))*lamda'  %计算级比偏差值，u(1)=a
```



### GM(2,1)、DGM、Verhulst



​	GM(1,1)只适用于有强指数规律的序列，只能描述单调的变化过程；对于非单调的摆动发展序列或者有饱和的S形序列可考虑建立题头的三种模型。

#### GM(2,1)

​	白化方程可写为$\frac{d^2x^{(1)}}{dt^2}+a_1\frac{dx^{(1)}}{dt}+a_2x^{(1)}=b$，即表示单变量二阶微分方程。

```matlab
%ex15_3.m
clc,clear
x0=[41,49,61,78,96,104]; %原始序列
n=length(x0); 
x1=cumsum(x0)  %计算1次累加序列
a_x0=diff(x0)' %计算1次累减序列
z=0.5*(x1(2:end)+x1(1:end-1))'; %计算均值生成序列
B=[-x0(2:end)',-z,ones(n-1,1)]; 
u=B\a_x0   %最小二乘法拟合参数
syms x(t)
x=dsolve(diff(x,2)+u(1)*diff(x)+u(2)*x==u(3),x(0)==x1(1),x(5)==x1(6)); %求符号解
xt=vpa(x,6) %显示小数形式的符号解
%此处指定范围，可以进行预测；后面都是计算残差、误差确定精度
yuce=subs(x,t,0:n-1); %求已知数据点1次累加序列的预测值
yuce=double(yuce) %符号数转换成数值类型，否则无法作差分运算
x0_hat=[yuce(1),diff(yuce)]; %求已知数据点的预测值
x0_hat=round(x0_hat) %四舍五入取整数
epsilon=x0-x0_hat    %求残差
delta=abs(epsilon./x0)  %求相对误差
```

#### DGM	

​	白化方程为$\frac{d^2x^{(1)}}{dt^2}+a_1\frac{dx^{(1)}}{dt}=b$

```matlab
clc,clear
x0=[2.874,3.278,3.39,3.679,3.77,3.8]; %原始数据序列
n=length(x0);
a_x0=diff(x0)';  %求1次累减序列，即1阶向前差分
B=[-x0(2:end)',ones(n-1,1)]; 
u=B\a_x0  %最小二乘法拟合参数
syms x(t)
d2x=diff(x,2); dx=diff(x); %定义一阶导数，是为了下面赋初值
x=dsolve(d2x+u(1)*dx==u(2),x(0)==x0(1),dx(0)==x0(1));  %求二阶微分方程符号解
xt=vpa(x,6) %显示小数形式的符号解
%求预测值
yuce=subs(x,'t',0:n-1); %求已知数据点1次累加序列的预测值
yuce=double(yuce) %符号数转换成数值类型，否则无法作差分运算
x0_hat=[yuce(1),diff(yuce)] %求已知数据点的预测值
epsilon=x0-x0_hat %求残差
delta=abs(epsilon./x0)  %求相对误差
```

#### Verhulst预测模型

​	主要用来描述具有饱和状态的过程，即S型过程，常用于人口预测，生物生长等。白化方程为$\frac{dx^{(1)}}{dt}+ax^{(1)}=b(x^{(1)})^2$

```	matlab
clc,clear
x0=[4.93   2.33   3.87   4.35   6.63   7.15   5.37   6.39   7.81   8.35];
x1=cumsum(x0);  %求1次累加序列
n=length(x0);
z=0.5*(x1(2:n)+x1(1:n-1));   %求x1的均值生成序列
B=[-z',z'.^2];
Y=x0(2:end)';
u=B\Y     %估计参数a,b的值
syms x(t)
x=dsolve(diff(x)+u(1)*x==u(2)*x^2,x(0)==x0(1));  %求符号解
xt=vpa(x,6) %显示小数形式的符号解
%预测
yuce=subs(x,'t',[0:n-1]); %求已知数据点1次累加序列的预测值
yuce=double(yuce) %符号数转换成数值类型，否则无法作差分运算
x0_hat=[yuce(1),diff(yuce)] %求已知数据点的预测值
epsilon=x0-x0_hat    %求残差
delta=abs(epsilon./x0)  %求相对误差
xlswrite('book4.xls',[x0',x0_hat',epsilon',delta'])
```

## 15.3、差分模型

​	产古药根据统计数据用最小二乘法来拟合差分方程的系数。其系统稳定性讨论要用到代数方程的求根。

​	差分模型利用差分方程，即递推式，可能是一阶也可能是二阶。

​	

## 15.4、马尔可夫预测

​	某一系统在已知现在情况的条件下，系统未来时刻的情况只与现在有关，而与过去的历史没有直接关系。这种随机模型称为马尔可夫模型。

​	$\{\xi_n,n=1,2,...\}$是一个随机序列，计算一条链上的状态转移概率有$P\{\xi_{n+m}=j|\xi_n=i\}=p_{ij}(m)$，称$P_{ij}(m)$为系统由状态i经过m个时间间隔转移到状态j的转移概率。这个式子表示时齐性

### 转移概率矩阵&科尔莫哥洛夫定理

​	对一个马尔可夫链，按照路径上的转移概率矩阵称为$P(m)=(p_{ij}(m))$，称其为马尔可夫链的m步转移矩阵。

​	例子：计算机状态分为1和0，计算子串数目，即00、01、10、11的数目，然后就可以计算出状态转移的概率分别是多少

​	可以使用下面的通用代码计算得到马尔卡夫状态转移矩阵：

```matlab
clc, clear, format rat
%a应该是一个记录状态的矩阵
a=[4  3  2  1  4  3  1  1  2  3 
   2  1  2  3  4  4  3  3  1  1
   1  3  3  2  1  2  2  2  4  4
   2  3  2  3  1  1  2  4  3  1];
a=a'; a=a(:)'; %把矩阵a逐行展开成一个行向量
for i=1:4
   for j=1:4
      f(i,j)=length(findstr([i j],a)); %统计子串‘ij’的个数
   end
end
ni=sum(f,2);  %计算矩阵f的行和
phat=f./repmat(ni,1,size(f,2))  %求状态转移的频率
format %恢复到短小数的显示格式
```

​	利用马尔卡夫状态转移矩阵可以得到第n步的概率为$P^{(n)}=P^{(0)}P^n$，进一步当$n\rightarrow \infin$时可以得到极限概率分布。

​	可以根据状态转移矩阵求得其解析解：

​	例子：列属性表示开始属性，行属性表示结束属性。

```matlab
0.8	0.1	0.1
0.5	0.1	0.4
0.5	0.3	0.2
```

​	$p_1=0.8p_1+0.5p_2+0.5p_3$

​	$p_2=0.1p_1+0.1p_2+0.3p_3$

​	$p_3=0.1p_1+0.4p_2+0.3p_3$

​	$p_1+p_2+p_3=1$

​	就可以得到解析解，代码如下

```matlab
format rat  %有理分数的数据格式
%改变代码时只需要把3改为状态数量就可以
p=[0.8 0.1 0.1;0.5 0.1 0.4;0.5 0.3 0.2];
a=[p'-eye(3);ones(1,3)];  %构造方程组ax=b的系数矩阵 
b=[zeros(3,1);1];  %构造方程组ax=b的常数项列
p_limit=a\b  %求方程组的解
format %恢复到短小数的显示格式
```

