# SML学习笔记

​	由于typora不支持sml所以我在代码块选择了（相对来说）比较接近的scheme语言。



## 二、名字函数和类型

### 2.1 命名常量

​	常量的命名以val关键字开始，以分号结束：

```scheme
val seconds = 60;
```

​	`it`变量总是维持着最近一次输入的表达式的值（包括变量、函数等任意表达式），任何之前的值都会被丢弃。

### 2.2 声明函数

​	函数的命名以fun关键字开始，以分号结束：

```scheme
fun area(r) = pi*r*r;
```

​	上面显然r是形参（formal parameter），等号后面的是函数体（body）；其中形参的括号是可选的，下面的表述也成立：

```scheme
fun area r = pi*r*r;	(*嘻嘻，这是一条注释*)
```

​	**名字的重新声明**，重新给变量名赋予一个新的值并不会报错，这和python是类似的。

## 2.3 标识符

​	表示符（identifier）其实就是“名字”。

​	一个字母名字允许：字母开始，跟随任意数量的字母、数字、下划线、单引号。

​	一个符号名字允许：！ % & $ # + - * / : < = > ? @ \ ~ ` ^ |（注意不要和关键字冲突）。

​	此外下面这些组合是有语法含义的，不能使用：

```scheme
: | = => -> # :>
```

## 2.5 算术运算

​	基本运算：加（+），减（-），乘（*），除（div），取模（mod）。

​	负数使用`~`符号单独来表示，注意上面的除法也很特别。

​	科学计数法使用E表示，和C语言类似。

​	**类型约束**，某些函数是**重载**（overloaded，没错就是骨傲天）的，即有不止一个含义。比如加法对两个整数是可用的，对两个浮点数也是可用的，这就存在一种“重载”。重载有的时候需要显式地指出，如：

```scheme
fun square x = x*x;				(*没指明这个函数是给谁用的，被拒绝了*)
> Error~ Unable to resolve overloading for *
fun square x : real = x*x;		(*指明了是实数*)
> val square = fn : real -> real
```

​	类型约束可以出现在函数的任何地方。

​	**默认重载**，表现为上面对类型约束的严格要求，其初衷是允许不同精度的数据同时存在。

​	**标准库**，随便介绍几个了事。

```scheme
Int.abs ~4;
> 4 : int
```

